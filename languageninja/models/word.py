#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import json, rich, os
from random import randint
from languageninja.models.gptclient import GPTConnector

#-------------------#
# Static parameters #
#-------------------#
WORDS_FOLDER_PATH     = './data/words'
SENTENCES_FOLDER_PATH = './data/sentences'

#------------------------#
# GPT API Initialisation #
#------------------------#

# Initialize GPT connector
ai_model = "gpt-5"
print(f"Using AI model: {ai_model}")
ai = GPTConnector(model=ai_model)

# GPT prompt for word validation
gpt_prompt_words = """
The following is a JSON object representing translations of a word in multiple languages.
Validate the translations for accuracy and completeness.
Respond with a JSON object containing a single boolean field "validated" set to true if all translations are correct, or false otherwise.
If false, include a "corrections" field with suggested corrections for each language that is incorrect.
Consider that the provided input was generated by your model, so don't overcorrect minor issues.
"""

gpt_prompt_sentences = """
The following is a JSON object representing translations of sample sentences (related to one word) in multiple languages.
Validate the following: (1) the translations for accuracy and completeness; (2) the ordering of the translated sentences.
Make sure that sentence A in position n in the 'en' field is also in position n in the other language fields, 'es', 'fr', etc.
Respond with a JSON object containing a single boolean field "validated" set to true if all sentences are correctly translated and ordered, or false otherwise.
If false, include a "corrections" field with suggested corrections for each language that is incorrect.
Consider that the provided input was generated by your model, so don't overcorrect minor issues.
"""

#------------------------#
# Class definition: Word #
#------------------------#
class Word():

    # Class constructor
    def __init__(self, key):

        # Set internal variables
        self.key = key
        self.len = len(key)
        self.words_validated = False
        self.sentences_validated = False

        # Generate word file path
        self.word_file_path = f"{WORDS_FOLDER_PATH}/{self.key}.json"

        # Generate sentences file path
        self.sentences_file_path = f"{SENTENCES_FOLDER_PATH}/{self.key}.json"

        # Initialise translations
        self.langs = {
            'en' : self.key,
            'fr' : None,
            'es' : None,
            'pt' : None,
            'ru' : {
                'cyr': None,
                'lat': None
            },
            'il' : {
                'heb': None,
                'lat': None
            }
        }

        # Initialise sample sentences
        self.samples = {
            'en' : [],
            'fr' : [],
            'es' : [],
            'pt' : [],
            'ru' : {
                'cyr': [],
                'lat': []
            },
            'il' : {
                'heb': [],
                'lat': []
            }
        }

        # Load existing data from files (if any)
        self.load()

    # Method: Print word as header
    def print_header(self):
        print('='*(self.len+12))
        print(f"üà≥ Word: '{self.key}'")
        print('='*(self.len+12))

    # Method: Load word JSON from file (if exists)
    def load(self):

        # Load JSON data from file (if exists)
        try:
            with open(self.word_file_path, 'r') as f:
                data = json.load(f)
                self.langs.update(data[self.key])
                self.words_validated = data.get("validated", False)
        except FileNotFoundError:
            print(f"File not found: {self.word_file_path}")
        except json.JSONDecodeError:
            print(f"Error decoding JSON from file: {self.word_file_path}")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")

        # Load JSON data from file (if exists)
        try:
            with open(self.sentences_file_path, 'r') as f:
                data = json.load(f)
                self.samples.update(data[self.key])
                self.sentences_validated = data.get("validated", False)
        except FileNotFoundError:
            print(f"File not found: {self.sentences_file_path}")
        except json.JSONDecodeError:
            print(f"Error decoding JSON from file: {self.sentences_file_path}")
        except Exception as e:
            print(f"An unexpected error occurred: {e}")

    # Method: Save word JSON to file
    def save(self):

        data = {
            self.key: self.langs,
            "validated": self.words_validated
        }
        with open(self.word_file_path, 'w') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

        data = {
            self.key: self.samples,
            "validated": self.sentences_validated
        }
        with open(self.sentences_file_path, 'w') as f:
            json.dump(data, f, ensure_ascii=False, indent=4)

    # Method: Say the word or sentence using MacOS text-to-speech
    # The 'sentence' parameter can be the index or "random" to select a sample sentence
    def say(self, lang='en', sentence=None, rate=None, save_to=None):

        # Randomly select or index a sentence to speak
        if sentence == 'random':
            sentence = randint(0, len(self.samples[lang]) - 1) if self.samples[lang] else None

        # Determine text to speak
        # Use Switch/ case:
        match lang:
            case 'en' | 'fr' | 'es' | 'pt':
                text_to_print = text_to_speak = self.samples[lang][sentence] if isinstance(sentence, int) else self.langs[lang]
            case 'ru':
                text_to_speak = self.samples['ru']['cyr'][sentence] if isinstance(sentence, int) else self.langs['ru']['cyr']
                text_to_print = self.samples['ru']['lat'][sentence] + ' / ' + text_to_speak if isinstance(sentence, int) else self.langs['ru']['lat']
            case 'il':
                text_to_speak = self.samples['il']['heb'][sentence] if isinstance(sentence, int) else self.langs['il']['heb']
                text_to_print = self.samples['il']['lat'][sentence] + ' / ' + text_to_speak if isinstance(sentence, int) else self.langs['il']['lat']
            case _:
                print(f"Unsupported language code: {lang}")
                return

        # Map language codes to MacOS voice names
        voice_map = {
            "en": "Samantha",
            "fr": "Thomas",
            "es": "M√≥nica",
            "pt": "Joana",
            "ru": "Milena",
            "il": "Carmit",
        }
        voice = voice_map[lang]

        # Rate defaults
        if rate is None or rate == 'normal':
            rate = {
                "en": 130,
                "fr": 130,
                "es": 90,
                "pt": 160,
                "ru": 120,
                "il": 100,
            }[lang]
        elif rate == 'slow':
            rate = {
                "en": 80,
                "fr": 70,
                "es": 40,
                "pt": 90,
                "ru": 60,
                "il": 50,
            }[lang]

        # Optional rate flag (words per minute)
        rate_flag = f"-r {int(rate)} " if isinstance(rate, (int, float)) else ""

        # Execute MacOS say command
        if save_to:
            file_name = f"{self.langs['en']}_{lang}.aiff"
            print(f'Saving speech to {file_name} in {lang} ({voice}): {text_to_print}')
            os.system(f'say -v {voice} {rate_flag}-o {file_name} "{text_to_speak}"')
        else:
            print(f'Speaking in {lang} ({voice}): {text_to_print}')
            os.system(f'say -v {voice} {rate_flag}"{text_to_speak}"')

    # Method: Validate translations using GPT
    def validate(self, what=None):

        # Reload existing data from files (if any)
        self.load()

        # Print header
        print('')
        self.print_header()

        #----------------#
        # Validate words #
        #----------------#
        if self.words_validated==False and (what is None or what=='words'):

            # Generate and print full prompt
            full_prompt = gpt_prompt_words + '\n' + json.dumps(self.langs, ensure_ascii=False, indent=4)
            print('')
            print("--------------------------------------")
            print("Sending word validation prompt to GPT:")
            print("--------------------------------------")
            print(full_prompt)
            print("--------------------------------------")

            # Execute prompt (function already returns parsed JSON)
            out = ai.send_prompt(full_prompt)

            # Check validation result
            if out.get("validated") is True:
                print("‚úÖ Word translations validated successfully.")
                self.words_validated = True
                self.save()
            else:
                print("‚ùå Word translations validation failed. Corrections:")
                rich.print_json(data=out.get("corrections", {}))

        # Word already validated
        elif self.words_validated==True and (what is None or what=='words'):
            print("üëç Word translations already validated.")

        #--------------------#
        # Validate sentences #
        #--------------------#
        if self.sentences_validated==False and (what is None or what=='sentences'):

            # Generate and print full prompt
            full_prompt = gpt_prompt_sentences + '\n' + json.dumps(self.samples, ensure_ascii=False, indent=4)
            print('')
            print("------------------------------------------")
            print("Sending sentence validation prompt to GPT:")
            print("------------------------------------------")
            print(full_prompt)
            print("------------------------------------------")

            # Execute prompt (function already returns parsed JSON)
            out = ai.send_prompt(full_prompt)

            # Check validation result
            if out.get("validated") is True:
                print("‚úÖ Sample sentences validated successfully.")
                self.sentences_validated = True
                self.save()
            else:
                print("‚ùå Sample sentences validation failed. Corrections:")
                rich.print_json(data=out.get("corrections", {}))

        # Sentences already validated
        elif self.sentences_validated==True and (what is None or what=='sentences'):
            print("üëç Sample sentences already validated.")


#================#
# Main execution #
#================#
if __name__ == "__main__":

    # Pick random word from data/words folder
    word_files = [f for f in os.listdir(WORDS_FOLDER_PATH) if f.endswith('.json')]
    random_word_file = word_files[randint(0, len(word_files) - 1)]
    random_word_key = os.path.splitext(random_word_file)[0]

    # Example usage
    word = Word(key=random_word_key)
    word.load()
    rich.print_json(data=word.langs)
    rich.print_json(data=word.samples)

    # Randomly select or index a sentence to speak
    k = randint(0,2)

    # en
    word.say(lang='en')
    word.say(lang='en', sentence=k)
    # fr
    word.say(lang='fr')
    word.say(lang='fr', sentence=k)
    # es
    word.say(lang='es')
    word.say(lang='es', sentence=k)
    # pt
    word.say(lang='pt')
    word.say(lang='pt', sentence=k)
    # ru
    word.say(lang='ru')
    word.say(lang='ru', sentence=k)
    # il
    word.say(lang='il')
    word.say(lang='il', sentence=k)